<pre>
  BIP: ???
  Title: Per message peer authentication
  Author: Jonas Schnelli <dev@jonasschnelli.ch>
  Status: Draft
  Type: Standards Track
  Created: 2016-03-23
</pre>

== Abstract ==

This BIP describes a way how peers can send authenticated messages to other peers to access additional or limited services.

== Motivation ==

We assume peer operators want to limit the access of different services to a selective subset of peers. Such services could be resource intense transaction filtering, p2p communication encryption (see BIP xxx) or services that would lead to fingerprinting possibilities (fee-estimation, etc.). A simple authentication scheme based on elliptic cryptography will allow peers to identify each other and selective allow access to restricted services.

== Specification ==

The authentication scheme proposed in this BIP uses ECDSA, '''secrets will never be transmitted'''.
Authentication can be verified by verifying the signature with a provided "identity-pubkey" (standard ec pubkey).

=== Per message authentication ===
There is no authorization state (session).

Messages that require authentication must be wrapped in the described <code>auth</code> message wrapper.

=== Known-peers and authorized-peers database ===
Each peer that supports p2p authentication, must provide two user editable databases (can be a simple record-per-line file).
# '''known-peers''' contain known identity-pubkeys together with a network identifier (IP & port), similar to the "known-host" file supported by openssh.
# '''authorized-peers''' contains identity-pubkeys, together with allowed services (example: encryption,filtering,fee-estimation).

=== <code>Auth</code> p2p message wrapper ===
A peer can send an authenticate message by wrapping the desired message into an <code>auth</code>-message-wrapper to the remote peer.
The <code>auth</code> message wrapper has the same structure as other message types.

{|class="wikitable"
! Field Size !! Description !! Data type !! Comments
|-
| 33bytes || identity-pubkey || comp.-pubkey || The identity pubkey of the requesting peer
|-
| 8bytes || auth-msg-id || int64 || up-counting auth-msg-id (0 to INT64MAX)
|-
| 64bytes || signature || normalized comp.-signature || A signature of the hash that includes the complete auth message including the wrapped message
|-
| varint || wrapped-msg-size || ? || wrapped message size
|-
| data || wrapped-msg || ? || wrapped message including message header
|}

The <code>auth-msg-id</code> integer must be higher then the last known auth-msg-id (individual by peer). This will make reply-attacks much harder (attack scenario: re-use sniffed <code>auth</code> messages).

The requesting auth message must be responded with one or serval <code>auth</code> wrapped message(s). The response-auth message(s) must contain the identity-pubkey from the responding-peer. The <code>auth-msg-id</code> must contain a higher number then the <code>auth-msg-id</code> used in the auth message from the requesting peer.

If the responding peer could not lookup the requesting peer's identity-pubkey in the local authorized-peers database or if the responding peer could not verify the signature, the requested auth message must be ignored to avoid fingerprinting of peers with authentication support.

Responding peers must ignore (banning would lead to fingerprinting) the requesting peer after 5 unsuccessfully authentication tries to avoid resource attacks.

The responding auth message allows the requesting peer to verify the integrity of the remote peer and would identify a men-in-the-middle attack. The requesting peer must store the responding peer's identity-pubkey from an previous accepted authentication or from a pre-sharing of the identity-pubkeys over a different channel (PGP, etc.). '''Only the owner of the corresponding private-key can sign the <code>auth</code> message wrapper'''. A non-matching identity-pubkey must be reported to the user and must lead to manual action (re-setting the identity-pubkey).

The peers should display the identity-pubkey as a identity-address to the users, which is a base58-check encoded ripemd160(sha256) hash. The purpose of this is for better visual comparison (logs, accept-dialogs).
The base58check identity byte is <code>0x0F</code> followed by a identity-address version number (=<code>0xFF01</code>).

A identity address would look like <code>TfG4ScDgysrSpodWD4Re5UtXmcLbY5CiUHA</code> and can be interpreted as a remote nodes fingerprint.

== Compatibility ==

This proposal is backward compatible. Non supporting peers will ignore the <code>auth</code> message.

== Example of a successful auth interaction ==

Before authentication (once during peer setup or upgrade)
# Requesting peer and responding peer create each a idenitiy-keypair (standard ec priv/pubkey)
# Optional: requesting and responding peer share the identity-pubkey over a different channel
# Optional: responding peer stores requesting peer's identity-pubkey in its authorized-peers database (A)
# Optional: requesting peer stores responding peer's identity-pubkey in its known-peers database (B)

Authentication
# Requesting peer sends an <code>auth(version)</code> message
  auth:
    [33 bytes identity-pubkey (C)]
    [8 byte auth-msg-id (D)] (1 at this point)
    [64 bytes normalized compact signature (E)] (hash of the complete auth message including wrapped message)
    [? bytes varint length of wrapped message]
    [? bytes wrapped message including message header] (example: "version" message)

# Responding peer does a lookup of the provided identity pubkey (C) in the authorized-peers database (A)
# Requesting peer checks if D > lastknown(D)
# Responding peer verifies signature (E) with identity-pubkey (C)
# Responding peer processes wrapped message
# Responding peer replies with a corresponding "auth" message wrapper
    [33 bytes responding-peer-identity-pubkey (F)]
    [8 byte auth-msg-id (G)] (2 at this point [must always be higher])
    [64 bytes normalized compact signature (H)] (hash of the complete auth message including wrapped message)
    [? bytes varint length of wrapped message]
    [? bytes wrapped message including message header] (example: "version" or "verack" message)

# Requesting peer checks if G > D
# Requesting peer does a lookup of (F) in known-peers database (B)
# Requesting peer verifies signature (H) with identity-pubkey (F)
# Requesting peer processes wrapped message


== Reference implementation ==

== References ==

* [[bip-XXXX.mediawiki|BIP XXX: p2p communication encryption]]

== Copyright ==
This work is placed in the public domain.